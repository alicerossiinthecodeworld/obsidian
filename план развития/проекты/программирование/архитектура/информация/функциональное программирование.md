Любая парадигма программирования — по сути, свод правил. Что-то нам рекомендуют делать, а что-то строго запрещают. Кажется, это может ограничить возможности программиста, но парадигма приходит на помощь и предлагает ему свои, выверенные и доказанные инструменты и паттерны.

Например, на эти действия ФП накладывает вето:

- изменять переменные;
- писать функции, которые меняют или используют что-то за пределами собственного объявления;
- писать функции, которые ничего не возвращают.

Первая концепция ФП — чистая функция. Такая функция не взаимодействует с внешним миром, то есть все вычисления происходят только внутри функции. Иначе говоря, чистая функция не вызывает побочных эффектов (англ. side effects).

Напишем чистую функцию:
```
function sum(a: number, b: number) {
    return a + b;
} 
```

Функция, которая использует внешнее состояние или вызывает внутри себя сторонние функции, — не является чистой.

```
function noClearFn() {
    someVar = 'new value';
    return getData();
} 
```

## Ссылочная прозрачность

Ссылочная прозрачность (англ. referential transparency) — результат чистой функции. Она гарантирует, что при одних и тех же аргументах функции — её результат будет всегда одинаков.

В чистых ФП языках, к примеру Haskell, нельзя написать функцию, которая ничего не возвращает.



```
function sum(a: number, b: number) {
    return a + b;
} 
```

console.log

Вывод в консоль — сайд-эффект, так как вывод происходит за пределы функции, в консоль.


Date.now

Date.now каждый раз возвращает текущую дату, что противоречит ссылочной прозрачности


Math.random

Math.random возвращает новое число, что противоречит ссылочной прозрачности.


axios.get(...)

Запросы к серверу тоже попадают под понятие сайд-эффекта, так как сервер может прислать что угодно.

Сложно представить приложение, в котором нет запросов к серверу, да и работать с датами приходится часто. Мир, полный чистых функций, — утопия. Поэтому принято руководствоваться правилом 80/20, где 80% — чистые функции, а 20% — не чистые. Разумеется, эти числа условны. На начальных этапах достаточно, если вы стремитесь сделать функции чистыми там, где возможно.


# Функции высшего порядка

Вторая концепция ФП — функции высшего порядка. Такие функции могут принимать и возвращать другие функции. В JS мы часто пользуемся функциями высшего порядка. Функции, которые передаются в качестве аргумента другим функциям, называются ==**функциями первого класса.**==


Чтобы сделать тестирование кода проще, а код — лаконичней, нужно воспользоваться чистыми и стрелочными функциями. Спойлер: в функциональном программировании стрелочные функции называют лямбда-функции.

## Лямбда-функции

Лямбда-функции — это функции без имени. Они объявляются на месте использования. Опишем стрелочные функции, которые позволят сделать код более лаконичным:

const isString = value => typeof value === 'string' const makeNewData = (obj, key, fn) => isString(obj[key]) ? fn(obj[key]) : obj[key] const changeStringFields = (obj, fn) => Object.keys(obj).map(key => makeNewData(obj, key, fn))

```
(a, b) => a + b 
```

# Частично применимые функции

Следующая концепция ФП — каррирование, или частичное применение функций. Каррирование можно назвать следствием функций высшего порядка. В них мы можем не только принимать функцию в качестве аргумента, но и возвращать её в качестве результата выполнения.

Каррирование — это преобразование функции с несколькими аргументами в последовательность функций, каждая из которых принимает один аргумент. Это упрощает создание функций высшего порядка и работу с асинхронным кодом. В функциональных языках программирования это помогает частично применять функцию к аргументам, создавая новые функции для последующего использования.

function curryMultiply(a) { return function(b) 
{ return a * b; }; } 
const double = curryMultiply(2); 
console.log(double(5))


# Неизменяемость данных

В ФП понятие переменной отличается от того, к которому мы привыкли. Переменную в ФП нельзя изменять. А если необходимо обновить её значения, следует создать новую переменную.

[[Чистая архитектура/По главам/Парадигмы программирования/Функциональное программирование|Функциональное программирование]]
[[Чистая архитектура]]**