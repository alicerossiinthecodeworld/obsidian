Мы вызывали метод `json` асинхронно. Нужно было дождаться события загрузки данных, а затем превратить ответ в объект JSON:

Скопировать кодJAVASCRIPT

```

fetch('https://api.kanye.rest')
  .then(res => res.json())
  .then((result) => {
    console.log(result);
  }); 
```

Пока мы не получим ответ сервера и тело целиком, мы не сможем привести его к JSON. Отсюда и асинхронный парсинг.

С запросом ситуация такая же: если он дошёл до сервера, это ещё не значит, что пользовательские данные пришли полностью.

Для работы с телом запроса есть специальная структура — поток (англ. stream). Чтобы полностью получить тело запроса, нужно принять все блоки и склеить их.

### Что обрабатывать, когда приходит блок? Событийная модель

Приход каждого блока — отдельное событие. Чтобы его обработать, пользуйтесь методом `on` объекта запроса:

Скопировать кодTYPESCRIPT

```
import http, { IncomingMessage, ServerResponse } from 'http';

const server = http.createServer((req:IncomingMessage, res:ServerResponse) => {
  req.on('data', (chunk) => {
    console.log(chunk); // <Buffer 66 69 65 6c 64 3d 76 61 6c 75 65>
  });
});

server.listen(3000); 
```

Каждый поступивший блок нужно добавлять в одну переменную. После того как придёт последний пакет, мы целиком получим тело ответа:

Скопировать кодTYPESCRIPT

```
import http, { IncomingMessage, ServerResponse } from 'http';

const server = http.createServer((req:IncomingMessage, res:ServerResponse) => {
  let data = '';
  // обработчик события «получен пакет данных»
  req.on('data', (chunk) => {
    data += chunk.toString();
  });
});

server.listen(3000); 
```

# Как выполняется код в Node.js. EventLoop

В Node.js JS-код приложения выполняется в одном потоке. Это значит, что в момент времени может совершаться только одна задача. Например:

Скопировать кодTYPESCRIPT

```
function sleep(msec: number) {
  const end = new Date().getTime() + msec;
  while(new Date().getTime() < end) {}
}

console.log("Запуск приложения");

sleep(3000);

console.log("Выполнение действия");
console.log("Завершение работы"); 
```

Мы заблокировали выполнение кода на 3 секунды при помощи функции `sleep`. Пока она выполняется, никакая другая операция не будет осуществлена. Это и есть однопоточность в Node.js.

## Событийный цикл Node.js

После запуска приложения выполняется его код: сперва синхронные операции, затем обращение к асинхронным API или, при необходимости, установка таймеров