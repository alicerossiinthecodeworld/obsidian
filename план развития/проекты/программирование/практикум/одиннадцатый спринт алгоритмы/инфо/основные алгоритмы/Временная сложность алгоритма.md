#подготовкасобесу
#js #фибоначчи #алгосы #книги  #одиннадцатыйспринт #яндекс #сложность


Возьмём простую функцию и рассчитаем временную сложность:


```
const sum = (nums: number[]): number => {
    let sum = 0;

  for (let i = 0; i < nums.length; i++) {
        sum += nums[i]
  }

  return sum;
} 
```

Временная сложность оценивает время работы программы. Чем больше операций нужно выполнить, тем дольше программа будет работать.

Выпишем все операции в функции `sum` и посчитаем их общее число:

`let sum = 0` –– создание переменной,

`let i = 0` –– создание переменной,

`i < nums.length` –– проверка условия,

`i++` –– инкремент переменной,

`nums[i]` –– доступ к элементу массива,

`sum += nums[i]` –– инкремент переменной.

Последние четыре операции находятся в цикле и выполняются конкретное число раз –– `nums.length`. Посчитаем сумму всех операций: 4 операции в цикле нужно умножить на количество итераций цикла (`nums.length`) и прибавить 2 первые операции в функции. Получится: `2 + 4 * nums.length`. При длине массива `n` получаем выражение `2 + 4n`.

А так изменяется выражение при разных значениях `n`:

|n|2 + 4n|Δ|
|---|---|---|
|1|6||
|10|42|7|
|100|402|9.5714|
|1000|4002|9.9552|
|10000|40002|9.9955|
|100000|400002|9.9995|
|1000000|4000002|9.9999|
Это и есть асимптотический анализ — мы оцениваем, как сложность алгоритма растёт с ростом входных данных. Важен только характер изменения функции, поэтому мы опускаем все константные коэффициенты и члены, кроме значимого.

Функция `2+4n` даёт сложность О(�)О(n). Читается как «О большое от n». Записать можно так: 2+4�=О(�)2+4n=О(n), или О(2+4�)=О(�)О(2+4n)=О(n). Значит, что эта функция растёт не быстрее, чем функция `n`, умноженная на константу. Что правда, ведь обе функции линейные.


# Оценка сложности разных операций

При оценке сложности алгоритма следует учитывать, что элементарные операции не зависят от структуры и объёма данных, с которыми работают. К ним относят присвоение значений  #переменные(`a = 5`), математические операции (`2*2`), обращение к полям объекта (`obj.a`), проверка логических условий (`a < 5`). Все они работают достаточно быстро, поэтому при расчёте сложность таких операций принимают за единицу и просто считают количество таких операций.


```
const printNames = (people: { name: string }[]): string => {
  const names = people.map(p => p.name); // О(n), считаем как n операций
  return names.join(', '); // О(n), считаем как n операций
} 
```

Сложность функции `printNames` равна сумме сложностей двух вызываемых внутри неё функций: `map` и `join`.

Итоговая сложность функции `printNames` равна О(�)+О(�)=О(2�)О(n)+О(n)=О(2n). Опустим константу 2 и получим сложность О(�)О(n).


Основные свойства О большого, которые нужны для оценки сложности:

1. �=О(�)f=О(f) — функция растёт не быстрее себя самой, умноженной на константу.
2. �+О(�)=О(�+�)f+О(g)=О(f+g) — складываем функцию `f` и некоторую функцию, растущую не быстрее, чем `g`. Получаем функцию, которая растёт не быстрее, чем функция `f+g`, умноженная на константу.
3. �∗О(�)=О(�∗�)f∗О(g)=О(f∗g) — умножаем функцию `f` на некоторую функцию, растущую не быстрее, чем `g`. Получаем функцию, которая растёт не быстрее, чем функция `f*g`, умноженная на константу.

В работе не всегда нужно считать все операции. Достаточно суммировать сложность операций, которые зависят от размера данных, а элементарные операции опускать.

[[курс практикума фуллстак]]