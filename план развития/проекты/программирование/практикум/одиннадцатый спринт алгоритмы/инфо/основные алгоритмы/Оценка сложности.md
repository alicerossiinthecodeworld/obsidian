#подготовкасобесу

#сложность #подготовкасобесу

## Вычислительная сложность
Оценить вычислительную сложность — значит  вычислить разницу между объёмом входных данных и числом элементарных операций, выполняемых алгоритмом.

Объём = время * объем. Поэтому алгоритмы оценивают также по:

- временной сложности (time complexity). Она отражает скорость работы программы. Оценить временную сложность — значит оценить максимальное количество элементарных операций, проделываемых алгоритмом для решения задачи.
- пространственной сложности (space complexity). Оценить пространственную сложность — значит выяснить, как объём памяти, выделенный компьютером для работы алгоритма, меняется в зависимости от объёма входных данных.

как оценить?

### **Константная сложность О(1)О(1)**

Сложность алгоритма не зависит от входных данных.

Пример — целочисленное деление.

### **Логарифмическая сложность О(���(�))О(log(n))**

Сложность растёт логарифмически: на каждом шаге мы уменьшаем количество обрабатываемых данных в несколько раз. В информатике часто работают с логарифмами по основанию два. Значит, что уменьшают объём данных вдвое. Но на сложность алгоритма основание не влияет.

пример 
[[бинарный поиск]]

При каждой итерации массив делится пополам. Если изначально длина массива, например, 1024, то на второй итерации элементов останется 512, затем — 256, потом 128 и так далее.

### **Линейная сложность О(�)О(n)**
пример 

Сложность растёт прямо пропорционально росту данных. Получаем эту сложность всегда, когда создаём цикл по коллекции элементов.
[[нахождение минимума в несортированном массиве]]

#js #алгосы #книги #практикум #одиннадцатыйспринт #яндекс #фронтенд


### **Линейно-логарифмическая сложность О(�∗���(�))О(n∗log(n))**

пример:
[[нахождение пересечения двух массивов]]

внутри основного цикла по массиву `arr1` мы воспользовались бинарным поиском по массиву `arr2`. Обозначим размер `arr1` как `n`, размер `arr2` как `m`. Тогда сложность бинарного поиска по `arr2` будет �(���(�))O(log(m)). При этом мы запускаем его `n` раз в цикле по массиву `arr1`. Поэтому сложность алгоритма будет �(�∗���(�))O(n∗log(m)), где `n` — размер первого массива, `m` — размер второго.


### **Квадратичная сложность �(�2)O(n2)**

Квадратичная сложность растёт быстро, ведь при увеличении данных в 100 раз, объём вычислений вырастет в 10000 раз. Поэтому алгоритм с такой сложностью на больших данных работает медленно.[[нахождение пересечения двух массивов]]


# Оценка сложности алгоритма: асимптотический анализ
[[Временная сложность алгоритма]]
# Пространственная сложность алгоритмов

