#алгосы  #списки
Каждый из нас хоть раз да составлял какой-то список. Список вещей на море или список покупок (всё равно забывая что-то купить из него). Даже в HTML мы работаем со списками — создаём их с применением тегов `ul`/`ol` и `li`. Так и структуры данных не обошлись без списков.

Связный список — это структура данных с последовательным доступом к элементам, которая поддерживает операции добавления и удаления элементов.
В отличие от массива, списки не требуют выделения непрерывной области памяти. Каждый элемент хранится отдельно и связан с остальными по ссылке. Поэтому в списках элементы могут иметь значения разного типа — каждый элемент занимает столько памяти, сколько ему нужно.
## Типы списков

**Односвязный список** — тот, в котором каждый элемент ссылается только на следующий элемент.
пример : очередь на печать

**Двусвязный список** — тот, в котором каждый элемент ссылается на предыдущий и следующий элемент.

Может применяться, чтобы реализовать историю посещений и браузерные стрелки «Вперёд» и «Назад», с помощью которых можно перемещаться по страницам.

**Кольцевой список** — тот, в котором каждый элемент ссылается на следующий, а последний элемент ссылается на первый.

Пример кольцевого списка — маршрут путешественника. Из Саратова он полетит в Дублин, там сделает пересадку до Куала-Лумпур, а оттуда вернётся назад в Саратов. Над оптимизацией перемещений ему явно стоит поработать, но пока это не наша задача.

**Кольцевой двусвязный список** — двусвязный список, в котором последний элемент ссылается на первый, а первый — на последний.

Пример такого списка — хоровод. Люди держатся за руки и идут то вправо, то влево. В интерфейсе вам может потребоваться сделать карту метро с движущимися поездами — тут кольцевые двусвязные списки вам и пригодятся.

[[операции со связными списками]]

Преимущество связного списка перед массивом в том, что мы оперируем ссылками, а не реальными объектами. Разберём на примере добавления элемента в конец массива и в конец связного списка.

Допустим, мы создали массив из пяти элементов, под него произошло выделение памяти. Если захотим добавить шестой элемент, то память выделится заново под шесть элементов и пять элементов из старого массива скопируются в новый, большего размера. А это довольно медленно. Сейчас в современных фреймворках нас, конечно, спасают разные оптимизации, но раньше было совсем тяжело.

В связных списках дело обстоит иначе. Последний элемент списка содержит ссылку, хоть и пустую `next: null`, соответственно, и место под неё было выделено ещё при создании последнего элемента. Когда захотим добавить новый элемент в список, место под него уже будет. Дополнительно не придётся ничего выделять и копировать предыдущие элементы.

[[план практикума алгосы]]
[[курс практикума фуллстак]]
